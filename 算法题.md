[Unity游戏开发客户端面经算法](https://blog.csdn.net/Sea3752/article/details/127554813)
# 1.十大排序算法
| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
| --- | --- | --- | --- | --- | --- | --- |
| 冒泡排序 | O(n^2) | O(n) | O(n^2) | O(1) | In-place | 稳定 |
| 选择排序 | O(n^2) | O(n^2) | O(n^2) | O(1) | In-place | 不稳定 |
| 插入排序 | O(n^2) | O(n) | O(n^2) | O(1) | In-place | 稳定 |
| 希尔排序 | O(nlogn) | O(nlog^2n) | O(nlog^2n) | O(1) | In-place | 不稳定 |
| 归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | Out-place | 稳定 |
| 快速排序 | O(nlogn) | O(nlogn) | O(n^2) | O(logn) | In-place | 不稳定 |
| 堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | In-place | 不稳定 |
| 计数排序 | O(n+k) | O(n+k) | O(n+k) | O(k) | Out-place | 稳定 |
| 桶排序 | O(n+k) | O(n + k) | O(n^2) | O(n+k) | Out-place | 稳定 |
| 基数排序 | O(n*k) | O(n*k) | O(n*k) | O(n+k) | Out-place | 稳定 |
1. 冒泡排序，数组稳定，（无序区，有序区），从无序区交换最大元素到有序区前端。
2. 选择排序，数组不稳定，链表稳定，（有序区，无序区），从无序区找一个最小的元素跟在有序区后面，对数组：比较多，交换少。
3. 插入排序，数组、链表，（有序区，无序区），把无序区的第一个元素插入到有序区的合适位置，对数组：比较少，交换多。
4. 堆排序，数组，（最大堆，有序区）从堆顶把根卸出来放在有序区之间，再恢复堆。
5. 归并排序，数组、链表，把数据分为两段，从两端中逐个选最小的元素移入新数据段的末尾，可以从上到下或从下到上进行。
6. 快速排序，数组，（小数，基准元素，大数），在区间中随机挑选一个元素作为基准，将小于基准的元素放在基准之间，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。
7. 希尔排序，数组，每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定是1。
8. 计数排序，数组、链表，统计小于等于该元素值的元素个数i，于是该元素放在目标数组的索引i位。
9. 桶排序，数组、链表，将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。
10. 基数排序，数组、链表，一种多关键字的排序算法，可用桶排序实现。
* 时间复杂度：O（n^2）,冒泡排序、选择排序、插入排序。
* O（nlogn）,快速排序、堆排序、（归并排序）。
* 不稳定的排序：选择排序、快速排序、堆排序、希尔排序。
* 基本有序用插入排序，不要用快速排序（最坏情况）
[十大排序从入门到入赘](https://leetcode.cn/discuss/post/3566135/shi-da-pai-xu-cong-ru-men-dao-ru-zhui-by-pl2j/)
# 2.100万的数据选出前1万大的数
* 使用堆排序实现，选用小顶堆
* 选择前1w个数建堆，然后遍历剩下的数，如果比堆顶（1w个数中最小的）大，则替换堆顶，调整堆仍然为最小堆，遍历完成后，堆中10000个数就是所需的最大的1w个数
* 建堆时间复杂度O（mlogm），算法的时间复杂度O（nmlogm），n为100，m为10000
* 如果有10亿个数，把10亿个数据分组存放，分别放在1000个文件中，在每个文件的100w个数据中找出最大的1w个数，合并到一起再找出1000*10000中的最终结果。
# 3.两个10G的文件，200M内存，排序
1. 把10G大小的文件拆成N个小文件，每个文件1M。
2. 把每个文件拉到内存排序，可以并行操作，在内存中使用快排，然后写入文件。
3. 对文件做两两合并。
# 4.A星算法
## 基本原理
* 避障碍寻路算法有很多，BFS，DFS，Dijkstra等
* BFS优点可以找到最优路径，缺点要遍历整张地图
* DFS优点不需要遍历整个地图，缺点不一定是最优路径
* Dijkstra优点可以无差别遍历当前最短路径，对于查找起始点到任意点的最短路径有效，缺点对于点到点的路径查找浪费
* A星算法可以很快找到一条相对最优的路径，搜索节点比前三个算法都要少
* A*吸收了DFS和BFS的优点，寻找到的路径优劣程度介于BFS和DFS之间，每一步都会更逼近终点
* A*算法就是不停的从起点开始遍历周围的点，找出目前来说消耗最小的点作为新的起点，直到找到终点。
* A*算法是一种启发式搜索算法，用于在图形平面上（存在障碍物）寻找从起点到终点的最短路径。
* open列表，知道但是没有走过的路，存放F、G、H、父对象的信息
* close列表，已经走过的路，存放在关闭列表中的点需要从开启列表移除，存放F、G、H、父对象的信息
* F = G + H，和值，走到终点消耗的代价值
* G值，从起点到当前位置的代价，已走过，准确可知，上下左右都是1，斜边用勾股定理算出为1.4
* H值，当前位置到终点的预估代价，为走过，预估值
* 在当前位置，求各个方向的F值，选最小的那个
* F值一样会走最后加入open表的格子
* 选择新的方向，不能在close表中，不能在open表中，合法（没有超过边界，不能是障碍物）
```
将起点加入close表
while(结束条件)
{
    获取close表的最后一个节点S
    获取S点周围所有符合加入条件（合法）的点，加入open列表
    计算open列表F值最低的格子T
    T从open表中删除加入close表
}
再次循环的时候，第一步获取的节点S就是最后加入的T

结束条件：若路径存在，终点所在节点加入close后，寻路结束
不存在路径，open列表不再有节点（无路可走）
```
* 结果是一条路径，需要反推回去，写Node的数据结构要记录这个节点从哪个节点走过来，找到父节点
* A星不停计算open表中最小值的格子，不会一条路走到黑，几条不同路径轮询探索，F值最低多个时可以随便选择
* 碰到死胡同，A星会换一条路径，而最终的路径通过回溯获取，并不是close表中格子都是路径，也有错路
## 如何确定路径
* 在关闭列表中从终点开始查找父对象，再查找父对象的父对象
* 死路：开启列表为空
## 详细流程
1. 将起点记录为当前点cur。
2. 将cur加入close列表，设置父对象为空。
3. 将cur周围所有合法（不在open列表或close列表、不是障碍）格子放入open列表。
4. 记录cur周围所有能合法格子的F值和父对象（cur）。
5. 在open列表寻找F值最小的点next加入close列表，并在open列表移除，每次往close列表放next时，判断是否为终点，如果是则结束寻路。
6. 将next设置为cur。
7. 重复3~6直到找到终点。
8. 从终点开始，通过父对象回溯，获取路径。